<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0051)https://csil.cs.uchicago.edu/minicourses/linux.html -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta http-equiv="Content-Style-Type" content="text/css">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Pablo Melana-Dayton">
  <meta name="author" content="David Noursi">
  <meta name="author" content="Kevin Zhao">
  <meta name="date" content="2016-10-02">
  <title>Introduction to Linux</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="./Introduction to Linux_files/minicourses.css" type="text/css">
</head>
<body>
<div id="header">
<h1 class="title">Introduction to Linux</h1>
<h2 class="author">Pablo Melana-Dayton</h2>
<h2 class="author">David Noursi</h2>
<h2 class="author">Kevin Zhao</h2>
<h3 class="date">2016-10-02</h3>
</div>
<h1 id="introduction">Introduction</h1>
<p>Linux is an operating system much like OS X or Windows. It has windows, programs, web browsers etc. Files are stored in directories which, in turn, are stored in other directories. You can access all of these features by using your mouse and double clicking on icons. As we perform more and more complex tasks we find that interacting with the computer graphically using the mouse is ineffective. Linux allows us to interact with the computer entirely through text using a program called the terminal. (Macs provide a similar terminal application, and there are ways to use text-based commands on Windows too. But, Linux provides the lowest barrier to entry.) In this lab you will learn how to use the terminal to perform some basic operations in Linux. You will need these skills for the rest of the course.</p>
<h1 id="objectives">Objectives</h1>
<ol style="list-style-type: decimal">
<li>Become familiar with the Linux environment</li>
<li>Learn basic terminal commands and how to work with a text editor</li>
<li>Learn to run a Python program from the command-line</li>
<li>Learn about file permissions</li>
<li>Learn about redirection and pipes</li>
<li>Learn about remote access tools.</li>
</ol>
<h1 id="terminal">Terminal</h1>
<p>On your personal computer, you probably navigate your hard drive by double clicking on icons. While convenient for simple tasks, this approach is limited. For example, imagine you wish to delete all of the music files over 5 MB that you haven't listened to in over a year. This task is very hard to do with the standard double-click interface but is relatively simple using the terminal.</p>
<p>Click the Application button (at the top left) and type "terminal" in the input box. Click the "terminal" icon to open the terminal window. Alternatively use the keyboard shortcut <code>Ctrl-Alt-T</code>.</p>
<p>A terminal window will open and you will see a string of the form:</p>
<pre><code>username@computer:~$</code></pre>
<p>where <code>username</code> has been replaced by your CNetID and <code>computer</code> is the name of the machine you happen to be using. This string is called the prompt. When you start typing, the characters you type will appear to the right of the <code>$</code>. The program that runs within a terminal window and processes the commands the you type is called a <em>shell</em>. We use <code>bash</code>, which is the default shell on most Linux distributions, but there are other popular shells, such as <code>ksh</code>, <code>tcsh</code>, etc.</p>
<h1 id="navigating-the-file-system">Navigating the File System</h1>
<p>Files in Linux are stored in directories/folders, just like in OS X/Windows. Directories can hold files or other subdirectories and there are special directories for your personal files, your Desktop, etc.:</p>
<table>
<colgroup>
<col width="18%">
<col width="18%">
<col width="20%">
<col width="39%">
</colgroup>
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Linux</th>
<th align="left">Mac</th>
<th align="left">Windows</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Root directory</td>
<td align="left">/</td>
<td align="left">/</td>
<td align="left">C:\</td>
</tr>
<tr class="even">
<td align="left">Home directory</td>
<td align="left">/home/usernam e</td>
<td align="left">/Users/usernam e</td>
<td align="left">C:\Documents and Settings\username</td>
</tr>
</tbody>
</table>
<p><img src="./Introduction to Linux_files/filesystem.username.svg" alt="image">{width="650" height="250"}</p>
<p>All of the computers in the lab are connected through a network file system. Effectively there is one very large shared hard drive. Your files are available from any lab computer and all of our directories live in the same space.</p>
<p>The figure above illustrates how Linux organizes the file system. Your own computer might have a slightly different organization (i.e. you might replace <code>/</code> with <code>C:</code>), but the idea is the same.</p>
<p>For the above and from this point forward, consider that the text "username" is replaced with your own actual username, which is just your CNetID.</p>
<h2 id="show-files">Show Files</h2>
<p>The terminal will start in your home directory, <code>/home/username/</code>, which is a special directory assigned to your user account. No matter which computer you will use in the CSIL it will automatically connect to your home directory and all files that you created or changed in previous sessions will be available to you.</p>
<p>Two very useful commands are <code>pwd</code> and <code>ls</code>:</p>
<table>
<colgroup>
<col width="13%">
<col width="83%">
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><code>pwd</code></td>
<td align="left">Prints your current Working Directory - tells you where you are in your directory tree.</td>
</tr>
<tr class="even">
<td align="left"><code>ls</code></td>
<td align="left">Lists all the files in the current directory.</td>
</tr>
</tbody>
</table>
<p>The following is an example using these two commands in a terminal window:</p>
<pre><code>username@computer:~$ pwd
/home/username/
username@computer:~$ ls      
Desktop  Documents  Downloads  Music  Pictures  Public  Templates  Videos
username@computer:~$  </code></pre>
<p>Try these commands yourself and verify that everything looks similar.</p>
<p>Notice that the directory path and list of files that you see if you open your home folder graphically are identical to those provided by <code>pwd</code> and <code>ls</code>, respectively. The only differences are the way you obtained the information and how it is displayed.</p>
<h2 id="change-directory">Change Directory</h2>
<table>
<colgroup>
<col width="25%">
<col width="74%">
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><p><code>cd &lt;path-name&gt;</code></p></td>
<td align="left"><p>change to the directory path-name</p></td>
</tr>
<tr class="even">
<td align="left"><p><code>cd ..</code></p></td>
<td align="left"><p>move up/back one directory</p></td>
</tr>
<tr class="odd">
<td align="left"><p><code>cd</code></p></td>
<td align="left"><p>move to your home directory</p></td>
</tr>
</tbody>
</table>
<p>How can we move around in the file system? If we were using a graphical system we would double click on folders and occasionally click the "back" arrow. In order to change to a different directory in the terminal, we use <code>cd</code> (change directory) followed by the name of the destination directory. (A note about notation: we will use text inside angle brackets, such as <code>&lt;path-name&gt;</code> as a placeholder. The text informally describes the type of value that should be supplied. In the case of <code>&lt;path-name&gt;</code>, the desired value is the path-name for a file. More about path-names later.) For example if we want to change to the <code>Desktop</code> directory, we type the following in the terminal:</p>
<pre><code>username@computer:~$ cd Desktop</code></pre>
<p>Here is an example of changing to the desktop directory in the terminal. We use <code>pwd</code> and <code>ls</code> to verify where we are and where we can go:</p>
<pre><code>username@computer:~$ pwd 
/home/username/
username@computer:~$ ls 
Desktop  Documents  Downloads  Music  Pictures  Public  Templates  Videos
username@computer:~$ cd Desktop
username@computer:~/Desktop$ pwd
/home/username/Desktop/
username@computer:~/Desktop$ ls

username@computer:~/Desktop$</code></pre>
<p>Notice that after we <code>cd</code> into the <code>Desktop</code> the command <code>pwd</code> now prints out:</p>
<pre><code>/home/username/Desktop/</code></pre>
<p>rather than:</p>
<pre><code>/home/username/</code></pre>
<p>In the beginning, there are no files in the Desktop directory, which is why the output of <code>ls</code> in this directory is empty.</p>
<p>We can move up one step in the directory tree (i.e. from <code>/home/username/Desktop</code> to <code>/home/username</code> or from <code>/home/username</code> to <code>/home</code>) by typing <code>cd ..</code> Here "up" is represented by "<code>..</code>" This command will move us up one level back to our home directory:</p>
<pre><code>username@computer:~/Desktop$ pwd
/home/username/Desktop/
username@computer:~/Desktop$ cd ..
username@computer:~$ pwd
/home/username/</code></pre>
<p>Notice that the working directory is also shown in the prompt string.</p>
<p>The tilde (<code>~</code>) directory is the same as your home directory: that is, <code>~</code> is shorthand for <code>/home/username</code>. Here's another useful shorthand: a single dot (<code>.</code>) refers to the current directory.</p>
<p>Usually when you use <code>cd</code>, you will specify what is called a "relative" path, that is, you are telling the computer to take you to a directory where the location of the directory is described relative to the current directory. The only reason that the computer knows that we can <code>cd</code> to <code>Desktop</code> is because <code>Desktop</code> is a folder within the <code>/home/username</code> directory. But, if we use a <code>/</code> at the <em>beginning</em> of our path, we are specifying the path relative to the the "root" or top of the file system. For example:</p>
<pre><code>username@computer:~$ pwd
/home/username/
username@computer:~$ cd /home/username/Desktop
username@computer:~/Desktop$ pwd
/home/username/Desktop
username@computer:~/Desktop$ cd /home/username
username@computer:~$ pwd
/home/username</code></pre>
<p>These commands achieve the same thing as the ones above it: we <code>cd</code> into <code>Desktop</code>, a folder within our home directory, and then back to our home directory. Paths that start with a <code>/</code> are known as <em>absolute paths</em>.</p>
<p>Running <code>cd</code> without an argument will take you back to your home directory without regard to where are you are in the file system. For example:</p>
<pre><code>username@computer:~/Desktop$ cd
username@computer:~$ pwd
/home/username</code></pre>
<h1 id="using-an-editor">Using an editor</h1>
<p><img src="./Introduction to Linux_files/ubuntu-sublime-1.png">{width="780px"}</p>
<p>How do we view and edit the contents of files? There are many high quality text editors for Linux. Today we will use <a href="http://www.sublimetext.com/">Sublime Text</a>, which is good for writing code.</p>
<p>Let's create a new file to start editing</p>
<pre><code>username@computer:~$ touch test.txt</code></pre>
<p>Open the file <code>test.txt</code> with <code>sublime-text</code> by typing the following into the terminal:</p>
<pre><code>username@computer:~$ sublime-text test.txt</code></pre>
<p>You should see an empty text file.</p>
<p>For now, we will use <code>sublime-text</code> in a very basic way. You can navigate to a particular place in a file using the arrow keys and then type standard characters and use the delete key as you would in a regular text editor. You can save your changes using the <code>save</code> option in the file menu or better, use the keyboard shortcut <code>Crtl-s</code>.</p>
<h3 id="exercises">Exercises</h3>
<p>Make sure that you are comfortable with this level of usage by</p>
<ol style="list-style-type: decimal">
<li>Adding your name to this file</li>
<li>Saving the file</li>
<li>Closing and reopening the file in <code>sublime-text</code> and ensuring that your name is still there.</li>
<li>Close <code>sublime-text</code>.</li>
</ol>
<h1 id="copy-cp-move-mv-remove-rm-and-make-directory-mkdir">Copy (<code>cp</code>), Move (<code>mv</code>), Remove (<code>rm</code>), and Make Directory (<code>mkdir</code>)</h1>
<table>
<colgroup>
<col width="42%">
<col width="57%">
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><p><code>cp &lt;source&gt; &lt;destination&gt;</code></p></td>
<td align="left"><p>copy the source file to the new destination</p></td>
</tr>
<tr class="even">
<td align="left"><p><code>mv &lt;source&gt; &lt;destination&gt;</code></p></td>
<td align="left"><p>move the source file to the new destination</p></td>
</tr>
<tr class="odd">
<td align="left"><p><code>rm &lt;file&gt;</code></p></td>
<td align="left"><p>remove or delete a file</p></td>
</tr>
<tr class="even">
<td align="left"><p><code>mkdir &lt;directoryname&gt;</code></p></td>
<td align="left"><p>make a new empty directory</p></td>
</tr>
</tbody>
</table>
<p>Sometimes it is useful to copy a file. To copy a file use the command:</p>
<pre><code>cp &lt;source&gt; &lt;destination&gt;</code></pre>
<p>where <code>&lt;source&gt;</code> is replaced by the name of the file you want to copy and <code>&lt;destination&gt;</code> is replaced with the desired name for the copy. An example of copying the file <code>test.txt</code> to <code>copy.txt</code> is below:</p>
<pre><code>username@computer:~$ cp test.txt copy.txt</code></pre>
<p><code>&lt;destination&gt;</code> can also be replaced with a path to a directory. In this case, the copy will be stored in the specified directory and will have the same name as the source.</p>
<h3 id="exercises-1">Exercises</h3>
<p>If you have not already done so, close <code>sublime-text</code> before you start these exercises. Your terminal is currently busy running the <code>sublime-text</code> program and will not be responsive until this program is closed.</p>
<p>Try to accomplish the following tasks to practice and check your understanding of these terminal commands.</p>
<ol style="list-style-type: decimal">
<li>Execute the above copy command and use <code>ls</code> to ensure that both files exist.</li>
</ol>
<p>Move (<code>mv</code>) has exactly the same syntax but doesn't keep the original file:</p>
<ol start="2" style="list-style-type: decimal">
<li>Move the file <code>copy.txt</code> to the name <code>copy2.txt</code>. Use <code>ls</code> to verify that this command worked.</li>
</ol>
<p>You can make a new directory with <code>mkdir directoryname</code>:</p>
<ol start="3" style="list-style-type: decimal">
<li>Make a new directory named <code>backups</code> using the <code>mkdir</code> command.</li>
</ol>
<p>Locations/paths can include directories:</p>
<ol start="4" style="list-style-type: decimal">
<li>Copy the file <code>copy2.txt</code> to the <code>backups</code> directory.</li>
</ol>
<p>You can list the files in a specific directory with <code>ls directoryname</code>:</p>
<ol start="5" style="list-style-type: decimal">
<li>Verify that step (4) was successful by listing the files in the <code>backups</code> directory.</li>
</ol>
<p>You can remove a file with the command <code>rm filename</code>:</p>
<ol start="6" style="list-style-type: decimal">
<li>Now that we have a copy of <code>test.txt</code> in the backups directory we no longer need <code>copy2.txt</code>. Remove the file <code>copy2.txt</code> in this directory.</li>
</ol>
<p>If you want to copy or remove an entire directory with all the files in it the normal <code>cp</code> and <code>rm</code> commands will not work. Use <code>cp -r</code> instead of <code>cp</code> or <code>rm -r</code> (the <code>r</code> stands for "recursive") instead of <code>rm</code> to copy or remove directories:</p>
<p>Make sure you want to remove <em>everything</em> in the named directory, including subdirectories, <em>before</em> you use <code>rm -r</code>.</p>
<h1 id="run-a-python-program">Run a Python program</h1>
<table>
<colgroup>
<col width="36%">
<col width="55%">
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><blockquote>
<p><code>python3 file.py</code></p>
</blockquote></td>
<td align="left"><blockquote>
<p>runs the python program file.py</p>
</blockquote></td>
</tr>
</tbody>
</table>
<p>To run a Python program, you just specify the command <code>python3</code> and the name of the file that contains your program.</p>
<p>Let's create a new python file. To do this, we will run <code>sublime-text</code> and create a new file. Save this file as <code>hello_world.py</code> in your home directory. Copy the following code into the file:</p>
<pre><code>print("Hello, World!")</code></pre>
<p>Save the file and exit <code>sublime-text</code></p>
<p>Use <code>ls</code> to verify that there there is a file <code>hello_world.py</code> in your <code>lab1</code> directory. Now run the program in the file <code>hello_world.py</code> typing in:</p>
<pre><code>python3 hello_world.py</code></pre>
<p>This program is a very simple. It just prints "Hello, World!" to the screen.</p>
<blockquote>
<p><strong>note</strong></p>
<p>There are several variants of Python, including Python 2.7 and Python 3. We will be using Python 3 and the corresponding <code>python3</code> interpreter. The CSIL machines have Python 2.7 installed as the default Python. As a result, the command <code>python</code> runs a version of Python 2.7. There are some differences between the two languages and your Python 3 program may not run properly using a Python 2.7 interpreter.</p>
</blockquote>
<h3 id="edit-and-run-a-python-program">Edit and run a Python program</h3>
<p>In this section you will modify and rerun the program in <code>hello_world.py</code>. This change is very simple but goes through all the mechanical steps necessary when programming.</p>
<p>You can open the file <code>hello_world.py</code> with the command:</p>
<pre><code>sublime-text hello_world.py</code></pre>
<p>The file contains a single line of code:</p>
<pre><code>print("Hello, World!")</code></pre>
<p>Change this line so that it instead says "Hello " and then your name. For example if your name was Barack Obama the line would read:</p>
<pre><code>print("Hello, Barack!")</code></pre>
<p>Do the following steps:</p>
<ol style="list-style-type: decimal">
<li>Save the file <code>hello_world.py</code> in <code>sublime-text</code> (forgetting to save is a surprisingly common error)</li>
<li>Rerun the program using <code>python3</code></li>
</ol>
<p>Is your terminal not responding? This behavior happens because it is busy running <code>sublime-text</code> so it can't hear you typing <code>python3</code> at it. You have three options:</p>
<ol style="list-style-type: decimal">
<li>Close <code>sublime-text</code>, do terminal work, reopen <code>sublime-text</code>. This routine is annoying.</li>
<li>Start a new terminal in the same location by clicking on your current terminal and pressing <code>Ctrl-Shift-N</code>. You can use this new terminal to run Python programs while the other runs <code>sublime-text</code>.</li>
<li><p>Close <code>sublime-text</code> and open it again but this time put a <code>&amp;</code> symbol at the end of the line. This means "Run Sublime-Text <em>and</em> let us do something else". You can then use the same terminal to run Python programs even while <code>sublime-text</code> is running:</p>
<pre><code>sublime-text hello_world.py &amp;</code></pre></li>
</ol>
<p>Option 1 may be seem the most natural to you. <strong>Do not chose Option 1.</strong> We strongly recommend getting the habit of keeping both your editor and a terminal window open at the same time. We've seen students waste a lot of time opening and closing their editor and terminal windows for no good reason.</p>
<p>Let's reinforce the steps to programming in Python with the terminal:</p>
<ol style="list-style-type: decimal">
<li>Change your <code>.py</code> file with an editor</li>
<li>Save the file</li>
<li>Run with <code>python3</code></li>
</ol>
<p>Forgetting to save the file (step 2) is a very common mistake!</p>
<h1 id="file-permissions">File Permissions</h1>
<p>Sometimes we want to restrict who can access certain resources on the file system.</p>
<p>Most file systems assign 'File Permissions' (or just permissions) to specific users and groups of users. Unix is no different. File permissions dictate who can read (view), write (create/edit), and execute (run) files on a file system.</p>
<p>All directories and files are owned by a user. Each user can be a member of 1 or more groups. To see your groups, enter the command 'groups' into the command line.</p>
<p>File permissions in Unix systems are managed in three distinct scopes. Each scope has a distinct set of permissions.</p>
<p><strong>User</strong> - The owner of a file or directory makes up the user scope.</p>
<p><strong>Group</strong> - Each file and directory has a group assigned to it. The members of this group makes up the group scope.</p>
<p><strong>Others</strong> - Every user who does not fall into the previous two scopes make up the others scope.</p>
<p>If a user falls into more than one of these scopes, their effective permissions are determined based on the first scope the user falls within in the order of user, group, others.</p>
<p>Users that fall into each scope can have three specific permissions.</p>
<p><strong>read</strong> - The read permission allows a user to view a file's contents. When set for a directory, this permission allows a user to view the names of files in the directory, but no further information about the files in the directory.</p>
<p><strong>write</strong> - The write permission allows a user to modify the contents of a file. When set for a directory, this permission allows a user to create, delete, or rename files.</p>
<p><strong>execute</strong> - The execute permission allows a user to execute a file (or program) using the operating system. When set for a directory, this permission allows a user to access file contents and other information about files within the directory (given that the file has the proper permissions for the user to access it). The execute permission does not allow the user to list the files inside the directory unless the read permission is also set.</p>
<p>Each permission has a unique value: read = 4, write = 2, execute = 1. As a result, you can describe the permissions of each scope using the sum of its permissions' values. For example, if a file has read and write permissions for the user scope, its permissions can be described as 6 (4 + 2 = 6).</p>
<p>Additionally, you can describe a file's permissions using these values for each scope. For example, 761 describes the permissions for a file with read, write, and execute permissions for the user scope, read and write permissions for the group scope, and only execute permissions for the others scope.</p>
<p>To list information about a file, including its permissions, type:</p>
<pre><code>ls -l &lt;filepath&gt;
&lt;permissions&gt; 1 owner group &lt;size in bytes&gt; &lt;date modified&gt; &lt;filepath&gt; </code></pre>
<p>For example, if we want information on <code>/usr/bin/python3.4</code>:</p>
<pre><code>username@computer:~$ ls -l /usr/bin/python3.4
-rwxr-xr-x 1 root root 3709944 Oct 14  2015 /usr/bin/python3.4</code></pre>
<p>First thing we can notice is that the owner of the file is a user named <code>root</code>. (FYI, <code>root</code> is a name for an account that has access to <em>all</em> commands and files on a Linux system. Other accounts may also have "root" privileges.)</p>
<p>The file's group is also <code>root</code>. The permissions are -rwxr-xr-x. These permissions are listed in user, group, and others order. In this example, the owner, <code>root</code>, can read, write, and execute the file. Users in the <code>root</code> group and all other users can read and execute the files.</p>
<h3 id="exercises-2">Exercises</h3>
<p>By default, any files or directories that you create will have your username as both the user and the group. (If you run <code>groups</code>, you'll notice that there is a group with the same name as your username. You are the only member of this group.) On our Linux machines, new files are given, by default, to give read and write permissions to user and group and no permissions to other. New directories will be set to have read, write and execute permissions for user and group.</p>
<ol style="list-style-type: decimal">
<li>Verify this claim by running <code>ls backups/copy2.txt</code> and <code>ls -d backups</code> in your home directory.</li>
</ol>
<p>The <code>-d</code> flag tells <code>ls</code> to list the directory, instead of its contents. Notice that that the first letter in the permissions string for <code>backups</code> is a d, which tells us that <code>backups</code> is directory. A regular file would have a <code>-</code> in that spot.</p>
<h2 id="changing-permissions-owner-group">Changing permissions, owner, &amp; group</h2>
<table>
<colgroup>
<col width="45%">
<col width="51%">
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><code>chmod &lt;permissions&gt; &lt;path-name&gt;</code></td>
<td align="left">set the permissions for a file/directory</td>
</tr>
<tr class="even">
<td align="left"><code>chmod &lt;changes&gt; &lt;path-name&gt;</code></td>
<td align="left">update the permissions for a file/directory</td>
</tr>
<tr class="odd">
<td align="left"><code>chown &lt;username&gt; &lt;path-name&gt;</code></td>
<td align="left">change the owner of a file to username</td>
</tr>
<tr class="even">
<td align="left"><code>chgrp &lt;group&gt; &lt;path-name&gt;</code></td>
<td align="left">change the group of a file</td>
</tr>
</tbody>
</table>
<p>To change permissions, we use the <code>chmod</code> command. This command can be used in two ways. We can set the permissions for a file using a 3 digit number (see above) or by adding to and/or removing permissions from the current settings. For example:</p>
<pre><code>username@computer:~$ echo "Hello!" &gt; testfile
username@computer:~$ ls -l testfile
-rw-rw-r-- 1 username username 7 Aug 23 11:22 testfile
username@computer:~$ cat testfile
Hello!
username@computer:~$ chmod 222 testfile #set only write permissions for all scopes
username@computer:~$ cat testfile
cat: testfile: Permission denied
username@computer:~$ chmod u+r testfile #give user scope read permissions</code></pre>
<p>In this last example, we have added user read permissions to <code>testfile</code>.</p>
<p>To change the owner of a file or directory (if you are the owner or root), you use the command:</p>
<pre><code>chown &lt;new owner&gt; &lt;path to file&gt;</code></pre>
<p>To change a file's group (if you are the owner or root):</p>
<pre><code>chgrp &lt;new group&gt; &lt;path to file&gt;</code></pre>
<h3 id="exercises-3">Exercises</h3>
<ol style="list-style-type: decimal">
<li>Change the permissions on <code>testfile</code> to allow group read and write access and read access for others. Run <code>ls -l testfile</code> to check the new permissions.</li>
<li>Remove write access from <code>testfile</code>. Check the corrected permissions.</li>
</ol>
<h1 id="wild-cards">Wild Cards</h1>
<p>Sometimes, when we enter a string, we want part of it to be variable, or a wildcard. A common task is to list all files that end with a given extension, such as <code>.txt</code>. The wildcard functionality, through an asterix, allows to simply say:</p>
<pre><code>username@computer:~$ ls *.txt</code></pre>
<p>The wildcard can represent a string of any length consisting of any characters - including the empty string.</p>
<p>It is important to be <strong>careful</strong> using wildcard, especially for commands like rm which cannot be undone. A command like:</p>
<pre><code>username@computer:~$ rm *             ### DO NOT RUN THIS COMMAND!</code></pre>
<p>will delete <strong>all</strong> files in your working directory!</p>
<h3 id="exercises-4">Exercises</h3>
<ol style="list-style-type: decimal">
<li>Navigate to the root directory. What do you see when you run <code>ls -d li*</code>? What about <code>ls -d li*/*</code>? (Note: the <code>-d</code> flag tells ls to just list directories, and not their contents)</li>
<li>Navigate to your home directory. What do you expect to see when you run <code>ls D*</code>?</li>
</ol>
<h1 id="environment-variables">Environment Variables</h1>
<table>
<colgroup>
<col width="39%">
<col width="58%">
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><code>printenv</code></td>
<td align="left">print the current state of the environment variables</td>
</tr>
<tr class="even">
<td align="left"><code>export</code> &lt;VARNAME&gt;="some value"</td>
<td align="left">define an environment variable</td>
</tr>
</tbody>
</table>
<p>Sometimes, when we have a string/path we use often, we can give it name by assigning it to a variable for convenience.</p>
<p>The command:</p>
<pre><code>username@computer:~$ printenv</code></pre>
<p>gives a long list of defined variables. Try it in your terminal to see what happens!</p>
<p>When we want to define new variables, we use the = operator and export command. As you found from using printenv, is typical to name environment variables in all capital letters, so we could define a new variable as simply:</p>
<pre><code>username@computer:~$ NEWVARIABLE="~/desired/path"</code></pre>
<p>It is important <strong>not to add spaces</strong>; the commands:</p>
<pre><code>username@computer:~$ NEWVARIABLE ="~/desired/path"
username@computer:~$ NEWVARIABLE= "~/desired/path"
username@computer:~$ NEWVARIABLE = "~/desired/path"</code></pre>
<p>would all be misinterpreted by the terminal; spaces within quotes are allowed, if accurate. To access environment variables in our commands, the $ sign must be used before the name of the variable, i.e.:</p>
<pre><code>username@computer:~$ NEWVARIABLE="~/desired/path"
username@computer:~$ cd NEWVARIABLE
error
username@computer:~$ cd $NEWVARIABLE
username@computer:~/desired/path$</code></pre>
<p>A variable created as above is only available to the current shell. It is a local variable, so future shells (such as those that you create when you open a new terminal window using <code>Ctrl-Shift-N</code>) will not have access to it. In order to save variables, we need to export them using the export command. Variables that are exported called environment variables, which are generally declared as follows:</p>
<pre><code>username@computer:~$ export NEWVARIABLE ="~/desired/path"</code></pre>
<h3 id="exercises-5">Exercises</h3>
<ol style="list-style-type: decimal">
<li>Define an environment variable and use <code>echo</code>, which takes a list of values as command-line arguments and echos them to the screen, to see its value.</li>
<li>Open a new terminal window and use <code>echo</code> in that window to see whether the variable is still defined.</li>
</ol>
<h1 id="man-pages">Man Pages</h1>
<p>A man page (short for manual page) documents or describes topics applicable to Unix programming. These topics include Unix programs, certain programming functions, standards and conventions, and abstract concepts.</p>
<p>To get the man page for a Unix command, you can type:</p>
<pre><code>man &lt;command name&gt;</code></pre>
<p>So in order to get the man page for <code>ls</code>, you can type:</p>
<pre><code>username@computer:~$ man ls</code></pre>
<p>This command displays a man page that gives information on the <code>ls</code> command, which includes a description, flags, instructions on use, and other information.</p>
<p>Each man page has a description. The <code>-k</code> flag for <code>man</code> allows you to search these descriptions using a keyword. For example:</p>
<pre><code>username@computer:~$ man -k printf</code></pre>
<p>This searches all the descriptions for the keyword <code>printf</code> and prints the names of the man pages with matches.</p>
<h1 id="sequential-commands">Sequential Commands</h1>
<p>It is often convenient to chain together commands that you want to run in sequence. For example, recall that if you want to print the working directory and list all of the files and directories contained inside, it would look something like this:</p>
<pre><code>username@computer:~$ pwd
/home/username/
username@computer:~$ ls
Desktop  Documents  Downloads  Music  Pictures  Public  Templates  Videos</code></pre>
<p>You could also run them together, like so:</p>
<pre><code>username@computer:~$ pwd ; ls
/home/username/
Desktop  Documents  Downloads  Music  Pictures  Public  Templates  Videos</code></pre>
<p>First, <code>pwd</code> is executed and run to completion, and then <code>ls</code> is executed and run to completion. The two examples above are thus equivalent, but the ability to run multiple commands together is a small convenience that could save you some time if there is a group of commands that you want to execute sequentially.</p>
<blockquote>
<p><strong>note</strong></p>
<p>The shell doesn't care about white space, so it will run any of the following as well:</p>
</blockquote>
<blockquote>
<p><code>&lt;username@computer&gt;:~$ pwd;ls</code></p>
<p><code>&lt;username@computer&gt;:~$ pwd ;ls</code></p>
<p><code>&lt;username@computer&gt;:~$ pwd; ls</code></p>
<p><code>&lt;username@computer&gt;:~$ pwd ; ls</code></p>
</blockquote>
<h1 id="useful-keyboard-shortcuts">Useful Keyboard Shortcuts</h1>
<p>Used at the Linux prompt, the keyboard shortcut <code>Ctrl-P</code> will roll back to the previous command. If you type <code>Ctrl-P</code> twice, you will roll back by two commands, etc. If you type <code>Ctrl-P</code> too many times, you can use <code>Ctrl-N</code> to move foward. The up and down arrows on your keyboard work in the same way.</p>
<p>Here are few more useful shortcuts:</p>
<ul>
<li><code>Ctrl-A</code> will move you to the beginning of a line.</li>
<li><code>Ctrl-E</code> will move you to the end of a line.</li>
<li><code>Ctrl-U</code> will erase everything from where you are in a line back to the beginning.</li>
<li><code>Ctrl-K</code> will erase everything from where you are to the end of the line.</li>
</ul>
<p>Play around with these commands. Being able to scroll back to, edit, and then rerun previously used commands saves time and typing!</p>
<h1 id="redirection">Redirection</h1>
<p>The examples in this section will use commands that we've not yet discussed. Refer to the man pages for information about unfamiliar commands.</p>
<p>As we already know, commands like <code>pwd</code>, <code>ls</code>, and <code>cat</code> will print output to screen by default. Sometimes, however, we may prefer to write the output of these commands to a file. In Linux, we can redirect the output of a program to a file of our choosing. This operation is done with the <code>&gt;</code> operator.</p>
<p>Try the following example and compare your output with ours:</p>
<pre><code>username@computer:~$ cd
username@computer:~$ touch test-1.txt
username@computer:~$ ls &gt; test-1.txt ; cat test-1.txt
Desktop
Documents
Downloads
Music
Pictures
Public
Templates
test-1.txt
Videos
username@computer:~$ echo "Hello World!" &gt; test-2.txt ; cat test-2.txt
Hello World!
username@computer:~$ cat test-2.txt &gt; test-1.txt ; cat test-1.txt
Hello World!</code></pre>
<p>Two important things to note:</p>
<ol style="list-style-type: decimal">
<li>If you redirect to a file that does not exist, that file will be created.</li>
<li>If you redirect to a file that is nonempty, the contents of that file will be <em>replaced</em>.</li>
</ol>
<p>You can use the append operator (<code>&gt;&gt;</code>) to append the output of command to the end of an existing file rather than replace the contents of that file.</p>
<p>Not only can we redirect the output of a program to a file, we can also have a program receive its input from a file. This operation is done with the <code>&lt;</code> operator. For example:</p>
<pre><code>username@computer:~$ echo &lt; test-2.txt</code></pre>
<p>In general, all Linux processes can perform input/output operations through, at least, the keyboard and the screen. More specifically, there are three 'input/output streams': standard input (or <code>stdin</code>), standard output (or <code>stdout</code>), and standard error (or <code>stderr</code>). The code in <code>my_echo.py</code> simply reads information from <code>stdin</code> and writes it back out to <code>stdout</code>. The redirection operators change the bindings of these streams from the keyboard and/or screen to files.</p>
<h1 id="piping">Piping</h1>
<p>In addition to the ability to direct output to and receive input from files, Linux provides a very powerful capability called piping. Piping allows one program to receive as input the output of another program, like so:</p>
<pre><code>username@computer:~$ program1 | program2</code></pre>
<p>In this example, the output of program1 is used as the input of program2. Or to put it more technically, the <code>stdout</code> of <code>program1</code> is connected to the <code>stdin</code> of <code>program2</code>.</p>
<p>As another more concrete example, consider the <code>man</code> command with the <code>-k</code> option that we've previously discussed. Let's assume that you hadn't yet been introduced to the <code>mkdir</code> command. How would you look for the command to create a directory? First attempts:</p>
<pre><code>username@computer:~$ man -k "create directory"
create directory: nothing appropriate
username@computer:~$ man -k "directory"
(a bunch of mostly irrelevant output)</code></pre>
<p>As we can see, neither of these options are particularly helpful. However, with piping, we can combine <code>man -k</code> with a powerful command line utility called <code>grep</code> (see man pages) to find what we need:</p>
<pre><code>username@computer:~$ man -k "directory" | grep "create"
mkdir (2)            - create a directory
mkdirat (2)          - create a directory
mkdtemp (3)          - create a unique temporary directory
mkfontdir (1)        - create an index of X font files in a directory
mklost+found (8)     - create a lost+found directory on a mounted Linux second extended fil...
mktemp (1)           - create a temporary file or directory
pam_mkhomedir (8)    - PAM module to create users home directory
update-info-dir (8)  - update or create index file from all installed info files in directory
vgmknodes (8)        - recreate volume group directory and logical volume special files</code></pre>
<p>Nice.</p>
<h3 id="exercises-6">Exercises</h3>
<ol style="list-style-type: decimal">
<li>Use piping to chain together the <code>cat</code> and <code>tail</code> commands to display the last 10 lines of <code>/var/log/syslog</code>.</li>
<li>Replicate the above functionality without using the <code>|</code> operator. (hint: Use a temporary file.)</li>
</ol>
<h1 id="remote-access">Remote Access</h1>
<p>There are two main tools for accessing a remote computer through the command line: one for running commands on the remote computer, and one for file transfer. The first of these commands is much more likely to be useful in this class.</p>
<h2 id="ssh">SSH</h2>
<p>SSH allows you to open a terminal session on a computer remotely, and is a major motivation for becoming proficient with the terminal. The following command:</p>
<pre><code>username@computer:~$ ssh username@domain</code></pre>
<p>begins an SSH session, and allows you to access all of your files and programs on the remote computer (as long as these programs can be executed through the shell). The URL for SSHing into CSIL Linux computers is:</p>
<pre><code>username@computer:~$ ssh CNETID@linux.cs.uchicago.edu</code></pre>
<p>You should try this now and ask a question if you have trouble, as it is something you may have to do for your CS classes here.</p>
<p>To exit an SSH session, simply use the command exit.</p>
<p><code>ssh</code> is installed by default on Linux and OSX. <a href="http://www.putty.org/">PuTTY</a> is a popular SSH client for Windows.</p>
<h2 id="scp">SCP</h2>
<p>While SSH allows you to log in to another computer, SCP provides the ability to transfer files between computers. In general, SCP is called as:</p>
<pre><code>username@computer:~$ scp user@host1:/path/to/file1 user@host2:path/to/file2</code></pre>
<p>and copies a file from one computer (the first argument) and places it in the second computer (the second argument).</p>
<p>If you want to copy a file to your local computer, you can simply specify the second argument as a filepath, without the username or domain name; the same principle applies for copying from your local computer.</p>
<p>If you want to leave the file named as it was, you don't need to specify the file name in the second argument.</p>
<p>An example of using SCP would be:</p>
<pre><code>username@computer:~$ ls
Desktop Downloads
username@computer:~$ scp userame@linux.cs.uchicago.edu:~/test.txt backups/
username@computer:~$ ls backups
Desktop Downloads copy2.txt test.txt</code></pre>
<p>Recall that a single dot (<code>.</code>) refers to the current directory.</p>
<h2 id="sftp">SFTP</h2>
<p>SFTP is essentially a combination of SSH and SCP. An SFTP session is started the same way as an SSH session is. Once in the session, you have two additional commands, get and put, which provide the functionality of SCP.</p>
<h1 id="final-notes">Final Notes</h1>
<p>Sometimes, a program will run indefinitely or misbehave. When this happens, you can type <code>Ctrl+C</code> to send an interrupt signal to the running program, which usually causes it to terminate. On occassion, you may need to type <code>Ctrl-C</code> a few times. Typing <code>Ctrl+D</code> sends an end of input signal, which tells the program that no more information is coming.</p>


</body></html>